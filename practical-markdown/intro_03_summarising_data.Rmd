---
title: "Session 3 - Summarising Data"
---

# Summarising Data

Summarising data with R and the tidyverse is generally straightforward. A complex data summary can be reduced to a series of smaller tasks - this is thinking like a programmer!

As we've seen, programming languages bear some resemblance to human languages, in that we can construct sentences using verbs and nouns. The nouns are the objects in our environment, and the verbs are the functions we apply to those objects.

Let's look at the tidyverse family of functions by examining a few key verbs for data manipulation: arrange(), filter(), select(), group_by(), mutate(), and summarise().

--

## Pipes

We have already seen one type of pipe, now it is time to introduce explicitly the most useful of the pipes, '|>'. This pipe takes what is on the left of the pipe and puts it into the first argument of what is on the right. Note: You may see '%>%' (the magrittr pipe) in older code - it works almost identically. Keep referring to this definition as you work through this code - it should become clear intuitively what the pipe is doing. Ctrl-Shift-M is a useful shortcut for inserting a pipe.

--

## Arrange

Let's start with arrange(). Arrange simply arranges the data in a particular order. Let's order the SDG data we used before by Gini coefficient. Note that the data is by default arranged from lowest to highest. We can alter this by specifying desc(), which will put the data in descending order.

We've used two pipes here -- first we took the sdg dataset and piped it into the arrange function (and thus sorting the dataset by Gini coefficient). We then took that sorted dataset and piped it into head() to view the first six rows. In this way, chaining pipes is like building up a sentence. We would have to use a number of nested brackets to do this otherwise, which is much harder to follow. If you have multiple pipes, it is generally good R syntax to start a new line each time you pipe, so it's clear what each line is doing.

```{r}
#--- Arrange by Gini
## English: first take the SDG dataset, then arrange it by Gini, then show the first 6 rows
sdg |> 
  arrange(gini) |> 
  head()

#--- Same code, no pipe
head(arrange(sdg, gini))

#--- Arrange by descending Gini
sdg |> 
  arrange(desc(gini)) |> 
  head()
```

> EXERCISE: Using arrange, which country has the highest GDP? Which has the lowest TB cure rate? How else might you get this information using what we've seen before?

```{r}

```

## Select

Select allows you to pick which variables you'd like to look at.

Here are some 'use cases' for select(). Check you understand what is happening in each line. I append head() to keep the output short - feel free to delete it.

```{r}
#--- View the names of the columns of the sdg dataset
names(sdg)

#--- Select only the TB column
sdg |> 
  select(tb) |> 
  head()

#--- Select every column between TB and TB Case Detection Rate
sdg |> 
  select(tb:case.d) |> 
  head()

#--- Select all the TB related columns and the country column
sdg |> 
  select(country, tb, tb.cure, case.d) |> 
  head()

#--- Select all the columns that are numeric
sdg |> 
  select(where(is.numeric)) |> 
  head()

#--- Select all the columns that start with 'tb'
sdg |> 
  select(starts_with("tb")) |> 
  head()

```

The modern way to select columns based on a condition is to use selection helpers like `where()` inside `select()`. This replaces the older `select_if()` function you might see in older code.

> EXERCISE: Extract all columns that have to do with population and save them as a data frame called 'pop'

```{r}

```

> EXERCISE: Extract all columns that contain the letter 'u' (Hint: ?select)

```{r}

```

> EXERCISE: Drop the lmic column (Hint: yes, this can be done with select!).

```{r}

```

> CHALLENGE EXERCISE: Move the gdp column to the front of the data frame, move the tb column to the back, and drop the urb, urb.pov, and urban.pov.hc variables (Hint: yes, this can also be done with select!).

```{r}

```

## Filter

Let's now examine filter(). Filter is select but for rows. What if we wanted to look at only some subsection of the data? The below code looks at some use cases for filter().

```{r}
#--- Filter the dataset to show only those countries with population below 1000000
sdg |> 
  select(country, pop) |> 
  filter(pop < 1000000) |> 
  head()

#--- Filter to only African nations
sdg |> 
  select(country, reg) |> 
  filter(reg == "AFR") |> 
  head()

#--- Filter to African nations with population below 1000000
sdg |> 
  select(country, pop, reg) |> 
  filter(reg == "AFR" & pop < 1000000) |> 
  head()

#--- Filter to African nations OR nations with population below 1000000
sdg |> 
  select(country, pop, reg) |> 
  filter(reg == "AFR" | pop < 1000000) |> 
  head()

#--- Filter to only nations with no missing data on slum prevalence
sdg |> 
  select(country, slums) |> 
  filter(!is.na(slums)) |> 
  head()
```

A few notes on filtering. You'll notice that for setting the filtering condition, we use two equals signs (==). This is because R will interpret a single equals sign as equivalent to the 'assignment operator' <-, which we definitely don't want! Note also that we had to enclose AFR in quotation marks. This is because AFR is stored as a character "string" - in other words, R views AFR as letters, not numbers, and not the name of the variable (which we can access without quotations).

You'll note that & means 'and', | means 'or', and ! means 'not'. Through combinations of these so-called logical operators, you can filter data in a number of ways.

What if I want to save the output of a call to filter() as a new data frame for analysis? Simple. I just assign the entire chain of code to a new object.

In sentences, the below code says 'I am going to filter the data frame 'sdg' to only African countries, and then I will call the new data frame that contains only those countries 'afr''

```{r}
#--- Filter to only African nations
afr <- sdg |> 
  filter(reg == "AFR")
```

> EXERCISE: Using filter and assignment, how many nations are there represented in the Eastern Mediterranean Region? How else can you get this information?

```{r}

```

## Mutate & Group By

We are going to introduce two new functions at once now.

mutate() is a function you will use a lot. It is used any time you wish to create a new variable. It comes in two main flavours: mutate() and transmute(). mutate() creates a new variable and preserves the existing one, while transmute() replaces the variable. mutate() returns the complete dataset, while transmute() returns only the variable that you transmuted (so you can think of it as mutate() + select()...).

Often we wish to conduct a particular action only split by some group in the data. Grouping doesn't change the look of the data, but changes how other functions work on the data.

### Mutate

Let's say we wish to look at gdp on a logarithmic scale. This is easily doable with mutate. Note the slightly different syntax, where you have to express the name of the new variable and assign using a single '=' instead of the assignment operator (<-). It's important to be clear on how ==, =, and <- are used differently.

```{r}
sdg |> 
  mutate(log.gdp = log(gdp)) |> 
  select(country, gdp, log.gdp) |> 
  head()
```

Sometimes we might wish to do more complex transformations. What if we wanted to look at the difference in GDP from the mean?

We add na.rm to the mean() function to tell R it should ignore missing values.

```{r}
sdg |> 
  mutate(diff.gdp = gdp - mean(gdp, na.rm = T)) |> 
  select(country, gdp, diff.gdp) |> 
  head()
```

To make a fairer comparison, we might want to look within each WHO region to determine how far each GDP is from its *regional* mean. We do this by adding a group_by() statement.

```{r}
sdg |> 
  group_by(reg) |> 
  mutate(diff.gdp = gdp - mean(gdp, na.rm = T)) |> 
  select(country, gdp, diff.gdp) |> 
  head()
```

The possibilities of mutate() are pretty endless. Here are a few use cases. We will look at recoding data with mutate() in the Tidying Data section (intro_04_.

```{r}
#--- Get the percentile rank of GDP
## The percentile rank is the percentage of values that are equal to or lower than the value in question
sdg |> 
  arrange(gdp) |> 
  mutate(perc = percent_rank(gdp)) |> 
  select(country, gdp, perc) |> 
  head()

#--- Divide TB incidence into quintiles
sdg |> 
  mutate(tb.quint = ntile(tb, 5)) |> 
  select(country, tb, tb.quint) |> 
  arrange(tb.quint) |> 
  head()

#--- Create a z score for proportion living in slums by region
# A z-score shows where the country sits on a bell curve of all recorded slum values
# The mean is at 0 and the standard deviation is 1 
sdg |> group_by(reg) |>  
  filter(!is.na(slums)) |> 
  mutate(z.slums = (slums - mean(slums))/sd(slums)) |> 
  select(country:reg, slums, z.slums) |> 
  arrange(reg, desc(z.slums)) |> 
  head()

#--- Convert all numeric variables to factor variables (using across)
sdg |> 
  mutate(across(where(is.numeric), as.factor)) |> 
  head()

#--- For reference: older code may use mutate_if()
# sdg |> mutate_if(is.numeric, as.factor)  # This still works but is superseded
```

When you want to apply the same operation to multiple columns, use across(). The across() function here works inside mutate() to apply transformations to multiple columns at once. The syntax is across(column_selection, function) where column_selection can use helpers like where(), starts_with(), ends_with(), or specific column names.

> EXERCISE: Create a new column where you replace each country's proportion living in slums variable with the mean proportion living in slums of its region

```{r}

```

> EXERCISE: Get the cumulative mean incidence of TB as you go from low GDP to high GDP. (hint: filter, arrange, mutate)

```{r}

```

> CHALLENGE EXERCISE: Plot the cumulative mean incidence of TB as you go from low to high GDP (hint: ?reorder)

```{r}

```

## Summarise

We may wish to generate summary statistics for a particular variable ourselves, rather than using summary. This is a job for summarise(). Let's investigate some summary statistics for TB cure rate.

Here we introduce another way to say filter(!is.na()) using complete.cases(). There is often more than one way to do something in R, as you've seen - this allows for soe creativity in coding!

```{r}
#--- Get summary statistics for TB cure rate
sdg |> 
  filter(complete.cases(tb.cure)) |> 
  summarise(mean = mean(tb.cure),
                  median = median(tb.cure),
                  sd = sd(tb.cure),
                  min = min(tb.cure),
                  max = max(tb.cure))

#--- Get same summary statistics grouped by region
sdg |> 
  filter(complete.cases(tb.cure)) |> 
  group_by(reg) |> 
  summarise(mean = mean(tb.cure),
                  median = median(tb.cure),
                  sd = sd(tb.cure),
                  min = min(tb.cure),
                  max = max(tb.cure))

#--- Summarising 
# You can also use across() within functions other than mutate!
sdg |> 
  summarise(across(where(is.numeric), mean, na.rm = TRUE)) |>
  head()
```

> EXERCISE: Variance is equal to the square of the standard deviation. Get the variance of maternal mortality by region.

```{r}

```

> EXERCISE: By World Bank GDP descriptor (lmic), calculate the mean proportion of individuals living *without* adequate sanitation.

```{r}

```

With just a handful of verbs from the tidyverse, we have seen how to perform a number of different data manipulations that can inform us about our data.

--

## Formatting Tables with kable()

When presenting summary statistics in reports or documents, we often want nicely formatted tables. The `knitr::kable()` function is a simple way to create publication-ready tables from R data frames.

Raw R output can be hard to read. kable() creates clean, formatted tables that: 
- Display nicely in R Markdown documents
- Are easier to read 
- Can be customized with options like digits for decimal places

Let's see it in action with our TB cure rate summary:

```{r}
#--- Create a summary table
tb_summary <- sdg |> 
  filter(complete.cases(tb.cure)) |> 
  group_by(reg) |> 
  summarise(mean = mean(tb.cure),
            median = median(tb.cure),
            sd = sd(tb.cure),
            n = n())

#--- Display with kable
tb_summary |> 
  knitr::kable(digits = 1,
               caption = "TB Cure Rate by WHO Region")
```


> EXERCISE: Create a summary table of maternal mortality (mmr) by LMIC status, showing mean, median, and count. Format it with kable() using 2 decimal places.

```{r}

```

--

## Integrating Summarising and Visualising

We can use the data we have summarised directly in a call to ggplot() to graph our newly summarised data. We are going to construct a concentration curve using some summarised data.

Each of the steps is outlined as followed:

1.  We select only the columns we need: GDP and TB (and country for info)
2.  We drop any variables that are missing either of these values
3.  We use mutate to generate a new variable representing the cumulative amount of GDP, that is, if we lined all the countries up from lowest GDP to highest GDP, this tells us what proportion of GDP we have accounted for as we move along.
4.  We use mutate to generate a new variable representing the cumulative amount of TB incidence.
5.  We plot that data, with cumulative GDP on the x axis and cumulative TB on the y axis.
6.  We add points to each country.
7.  We connect those points with a line.
8.  We add a diagonal line down the middle.
9.  We add a vertical line crossing the x axis at the value .10
10. We add labels
11. We remove the grey background.

Make sure you understand what each line is doing and what each element does! Play around with this code if something doesn't make sense - remove one line at a time and see what happens.

```{r}
#--- Plot a concentration curve
sdg |> 
  select(country, gdp, tb) |> 
  drop_na() |> 
  arrange(gdp) |>  # IMPORTANT: Sort by GDP before cumulative sum! 
  mutate(cumul.gdp = cumsum(gdp)/sum(gdp)) |> 
  mutate(cumul.tb = cumsum(tb)/sum(tb)) |> 
  ggplot(aes(x = cumul.gdp, y = cumul.tb)) +
  geom_point(color = "red") +
  geom_line() +
  geom_abline(color = "forestgreen") +
  geom_vline(xintercept = .10, color = "blue") + 
  labs(title = "Concentration Curve: TB vs GDP",
       x = "Cumulative % of GDP",
       y = "Cumulative % of TB") +
  theme_bw()
```

Voila - a beautiful plot! It is clear that countries that make up a small cumulative percentage of GDP account for a large cumulative percentage of TB cases. We can clearly see from our vertial line that the countries making up the lowest 10% of GDP account for about 50% of all total TB cases.

> EXERCISE: Save this plot!

```{r}

```


------------------------------------------------------------------------

## More Useful Functions - Optional extension

Here I outline a couple of other functions that you might find helpful to extend your understanding of the above:

### The count() Function

You'll often want to know how many observations there are in each category. While you can use `group_by() |> summarise(n = n())`, there's a much shorter way:

```{r}
#--- Count observations by region
sdg |> 
  count(reg)

#--- Count with sorting (most common first)
sdg |> 
  count(reg, sort = TRUE)

#--- Count by multiple variables
sdg |> 
  count(reg, lmic)

#--- Add proportions
sdg |> 
  count(reg) |> 
  mutate(proportion = n / sum(n))
```

> EXERCISE: Use count() to find out how many countries are in each World Bank income category (lmic). Which category has the most countries?

```{r}

```

--

### Advanced Usage of across()

We've seen across() used with select() and mutate() above. It's an incredibly versatile function for working with multiple columns at once. Here some other examples of across():

A couple of things to notice here:

In the second example, we select columns using c(). c() stands for concatenate. Instead of three columns, we now have one 'vector' containing three elements. across() takes a vector as its first argument: you cannot pass three things in the first 'slot' of the across function, so if you need to refer to multiple objects or values, they need to be in a list. Similarly, we wish to get both the mean and the sd, so we need to put those in a list as well.

In the fourth example, we have some complex syntax: `~ round(., 1)` -- this is called lambda notation. When we want to do something across multiple columns, like take the mean, it's fairly straightforward since mean() has only one mandatory object. However, for something like 'round()', we need to specify both the value to round and the number of decimal places. If we just type 'round' like we did 'mean', R will not have enough information. The tilde (~) tells R that you are going to use a function like round(). The '.' indicates where in that function the column name should go, because it's ambiguous where in the function it should go. We then specify the remaining argument to round().

```{r}
#--- Get mean of all numeric columns with summarise
sdg |> 
  summarise(across(where(is.numeric), mean, na.rm = TRUE)) |>
  head()

#--- Get multiple summary statistics for selected columns
sdg |> 
  summarise(across(c(tb, tb.cure, case.d), 
                   c(mean = mean, sd = sd), 
                   na.rm = TRUE))

#--- Apply different functions to different column sets
sdg |> 
  summarise(
    across(c(tb, mat.mort), mean, na.rm = TRUE),
    across(c(pop, gdp), sum, na.rm = TRUE)
  )

#--- Use across() with mutate() to transform multiple columns
sdg |> 
  mutate(across(starts_with("tb"), ~ round(., 1))) |> 
  select(country, starts_with("tb")) |> 
  head()
```

Key patterns to know:
- `where(is.numeric)` - selects all numeric columns 
- `starts_with("prefix")` - selects columns by prefix 
- `c(col1, col2, col3)` - selects specific columns 
- Can use `~` for lambda functions (e.g., `~ . * 100` to multiply by 100)

> EXERCISE: Calculate the median and IQR (interquartile range) for all columns that start with "tb" using across().

```{r}

```

--

### Understanding group_by() persistence

An important thing to know about group_by() is that grouping persists through your pipe chain until you explicitly remove it:

```{r}
#--- Group by region
sdg_grouped <- sdg |> group_by(reg)

#--- Check if it's grouped
sdg_grouped

#--- The grouping affects all subsequent operations
sdg_grouped |> 
  summarise(mean_tb = mean(tb, na.rm = TRUE))

#--- Even mutate respects the grouping
sdg_grouped |> 
  mutate(tb_diff_from_region_mean = tb - mean(tb, na.rm = TRUE)) %>%
  select(country, reg, tb, tb_diff_from_region_mean) %>%
  head()
```

This is usually what you want, but sometimes it can cause confusion. To remove grouping, use ungroup():

```{r}
#--- Remove grouping
sdg_ungrouped <- sdg_grouped |> ungroup()

#--- Now summarise operates on the entire dataset
sdg_ungrouped |> 
  summarise(mean_tb = mean(tb, na.rm = TRUE))
```

Always ungroup() when you're done with grouped operations to avoid unexpected behavior.

```{r}
#--- Good practice: ungroup at the end of your chain
sdg |> 
  group_by(reg) |> 
  mutate(tb_within_region = tb - mean(tb, na.rm = TRUE)) |> 
  ungroup() |>  # Clear grouping
  filter(country == "Afghanistan")
```

> EXERCISE: Create a new variable showing each country's GDP as a percentage of their region's total GDP. Make sure to ungroup at the end.

```{r}

```

------------------------------------------------------------------------

## Challenge Exercise

> CHALLENGE: Create a concentration curve for maternal mortality vs population (instead of TB vs GDP). The curve should show cumulative proportion of population on the x-axis and cumulative proportion of maternal deaths on the y-axis. Add appropriate labels and styling.

Hints: 

- Remember to arrange by population first before calculating cumulative sums 
- You'll need to calculate absolute number of deaths from the mortality rate and population 
- Add a reference line to show what perfect equality would look like

```{r}

```
