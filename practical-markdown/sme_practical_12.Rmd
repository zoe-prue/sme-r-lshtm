---
title: "SME 2026 - Practical 12"
author: Daniel J Carter
editor_options: 
  chunk_output_type: console
---

# Part 1: Mortality

Load packages & functions!

```{r}
library(haven)
library(tidyverse)
library(gtsummary)
library(here)
library(lmtest)
library(emmeans)

# Source custom functions
source(here("sme-2026/functions/mh_functions_updated.R"))

```

## Data import, exploration, management

Make sure you have the mortality.dta dataset in the data folder (or change the file path)

```{r import-data}
mortality <- read_dta(here("sme-2026/data/mortality.dta"))
mortality <- mortality |> mutate(across(where(is.labelled), as_factor))

glimpse(mortality)
summary(mortality)
#View(mortality)
```

1a. Explore the data. What type of variable (in R) are "systolic" and "died"? To which type of variable (in the data sense) does this type of variable (in R) correspond?

```{r}
# Check variable type
class(mortality$systolic)
class(mortality$died)

mortality <- mortality |>
  mutate(died = factor(
    died,
    levels = c(0, 1),
    labels = c("Alive", "Dead")
  ))
```

Plot systolic BP against death. What does the plot show?

```{r}
# Scatterplot
mortality |> 
  ggplot(aes(x = systolic, y = died)) +
  geom_point() +
  theme_bw() +
  labs(title = "Systolic blood pressure and death",
       x = "Systolic blood pressure",
       y = "Death")

# Box-and-whiskers plot
mortality |> 
  ggplot(aes(x = died, y = systolic)) +
  geom_boxplot() +
  labs(title = "Systolic blood pressure and death",
       y = "Systolic blood pressure",
       x = "Death") +
  theme_bw() +
  coord_flip()
```

1b. Group systolic into three levels and add labels.
- <120: normal
- 120-139: pre-hypertension
- 140+: hypertension

```{r}
# Could also do this with case_when!
mortality <- mortality |>
  mutate(systolic_grp = cut(
    systolic,
    breaks = c(0, 119, 139, +Inf),
    labels = c("Normal", "Pre-hypertension", "Hypertension")
  ))

# Check it worked
table(mortality$systolic, mortality$systolic_grp)
```

Explore the relation between systolic_grp and died.

```{r}
mortality |> 
  tbl_cross(row = systolic_grp, col = died, percent = "row")
```

1c + 1d. Calculate the OR of death in each sBP group compared to baseline, and test for linear trend. The tabodds() function calculates ORs for each level versus the reference group and provides a score test for trend.

```{r}
# OR and test for trend
tabodds(mortality, outcome = "died", exposure = "systolic_grp")
```

1e. Fit a logistic regression model for death, with exposure being grouped sBP treated as a continuous variable.

```{r}
# Recode systolic_grp as numeric
mortality <- mortality |>
  mutate(systolic_quant = as.numeric(systolic_grp))

# Check
table(mortality$systolic_grp, mortality$systolic_quant)

# Logistic regression with linear relation - log odds scale
model_cont <- glm(died ~ systolic_quant,
                    data = mortality,
                    family = binomial()) 
# OR scale
tbl_regression(model_cont, exponentiate = TRUE)
```

What is the interpretation of the estimate for grouped sBP?

1g. Fit a model with grouped sBP assuming factors and perform a LRT on the following hypotheses:
- H0: the effect of grouped sBP on log(odds) of death is linear
- H1: the relationship is not linear

```{r}
model_cat <- glm(died ~ systolic_grp,
                    data = mortality,
                    family = binomial())
tbl_regression(model_cat, exponentiate = TRUE)

# LRT
lrtest(model_cont, model_cat)
```

1h. Summarise your findings

1i. Recode the sBP groups so that it's a continuous variable, with each group containing a mid-point value in mmHg. Notice that we need to specify the data type to tell R that it's a continuous variable using as.numeric()

```{r}
# Recode the variable with (arbitrary) midpoints
mortality <- mortality |>
  mutate(systolic_grp_mid = as.numeric(
    case_when(
      systolic_grp == "Normal" ~ 110,
      systolic_grp == "Pre-hypertension" ~ 130,
      systolic_grp == "Hypertension" ~ 150)
  ))

# Check
table(mortality$systolic_grp, mortality$systolic_grp_mid)
```

Now fit the equivalent model to 1f. What changes?

```{r}
glm(died ~ systolic_grp_mid,
    data = mortality,
    family = binomial()) |>
  tbl_regression(exponentiate = TRUE)
```

2a. Consider a model with:
- outcome: death
- exposure: visual impairment
- confounder: age (agegrp)

Does our estimate of effect of visual impairment differ if we treat age as continuous rather than categorical? Fit a model using each specification of the variable.

```{r}
# Transform agegrp into a continuous variable
mortality <- mortality |>
  mutate(agegrp_cont = as.numeric(agegrp))

table(mortality$agegrp, mortality$agegrp_cont)

# Continuous model
model_cont <- glm(died ~ vimp + agegrp_cont,
                     data = mortality,
                     family = binomial())
tbl_regression(model_cont, exponentiate = TRUE)

# Categorical model
model_cat <- glm(died ~ vimp + agegrp,
                     data = mortality,
                     family = binomial())
tbl_regression(model_cat, exponentiate = TRUE)

# LRT
lrtest(model_cont, model_cat)
```

2b. Perform an LRT for the interaction between vimp and agegrp treated as continuous. Is there evidence that the association of visual impairment on death differs by age group, where age group is treated as continuous?

```{r}

# Logistic regression with interaction
model_int <- glm(died ~ vimp * agegrp_cont,
                       data = mortality,
                       family = binomial())
tbl_regression(model_int, exponentiate = TRUE)

# Model without interaction for LRT
model_noint <- glm(died ~ vimp + agegrp_cont,
                          data = mortality,
                          family = binomial())

# LRT
lrtest(model_noint, model_int)

# Calculate stratum-specific ORs for visual impairment for the four age group strata using the continuous model
# The at argument specifies which values of agegrp_cont to evaluate (so here, all unique values) and it must be passed as a list.
emmeans(model_int,
        revpairwise ~ vimp | agegrp_cont,
        at = list(agegrp_cont = unique(mortality$agegrp_cont)),
        type = "response") |>
  pluck("contrasts")
```

3. Using the Mwanza dataset, investigate the association between HIV infection and number of injections in the past year.

```{r}
# Import the dataset
mwanza <- read_dta(here("sme-2026/data/mwanza.dta"))

View(mwanza)
glimpse(mwanza)
summary(mwanza)
```

The variable "inj" is coded as follows:
1: does not inject
2-4: increasing number of injections per year
9: missing value

```{r}
mwanza <- mwanza |>
  mutate(hiv = as.factor(case_when(case == 1 ~ "HIV+",
                                   case == 0 ~ "HIV-")))

# Replace inj "9" with "NA"
mwanza$inj <- na_if(mwanza$inj, 9)
table(mwanza$inj)
mwanza |> 
  tbl_cross(row = hiv, col = inj)

# Logistic regression including the zero group (coded as 1...)
glm(hiv ~ inj,
    data = mwanza,
    family = binomial()) |>
  tbl_regression(exponentiate = TRUE)
```

Remember that the zero group should be excluded to confirm that a trend with increasing numbers is not simply induced by a difference between the zero category and the rest.

```{r}
# Logistic regression excluding the zero group
mwanza |>
  filter(inj != 1) |>
  glm(hiv ~ inj,
      data = _,
      family = binomial()) |>
  tbl_regression(exponentiate = TRUE)
```
