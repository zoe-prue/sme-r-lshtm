---
title: "SME 2026 - Practical 13: Matched Case-Control Studies"
author: Daniel J Carter
---

# Overview

In this practical, you will learn how to analyse matched case-control studies. Matching is a design strategy used to control for confounding by ensuring that cases and controls are similar with respect to potential confounders such as age or sex. The analysis of matched data differs from unmatched data because we must account for the dependence structure introduced by the matching.

By the end of this practical, you should be able to:

- Construct and interpret matched tables for paired case-control data
- Calculate odds ratios from matched tables using discordant pairs
- Understand why ignoring matching can bias results
- Use conditional logistic regression to analyse matched data
- Assess confounding in matched case-control studies

The practical uses two datasets from Brazil investigating risk factors for infant death from diarrhoea: diabraz.dta (1 control per case) and diabraz2.dta (2 controls per case). The exposure variables of interest are breastfeeding (bf), water supply (wat2), and birthweight (bwtgp).

---

# Setup

```{r setup}
# Load packages
library(haven)
library(tidyverse)
library(gtsummary)
library(here)
library(survival)  # for clogit()

# Source custom functions
source(here("sme-2026/functions/matched_functions.R"))
source(here("sme-2026/functions/or_function.R"))
source(here("sme-2026/functions/mh_functions_updated.R"))


# Set options
options(digits = 3, scipen = 999)
```

The survival package provides the `clogit()` function for conditional logistic regression, which is the standard method for analysing matched case-control data. We also load custom functions for creating matched tables and calculating matched odds ratios.

---

# Part 1: Individual Matching (Paired Data)

## Question 1: Data Import and Exploration

Import the diabraz dataset and explore its structure.

```{r import}
# Import data
diabraz <- read_stata(here("sme-2026","data", "diabraz.dta"))

# Explore the data
glimpse(diabraz)
summary(diabraz)
```

The variables in this dataset are not labelled, so here is the key information from the study documentation: the variable "case" indicates whether the infant died from diarrhoea (1) or is a control (0), "bf" indicates breastfeeding status, "bwtgp" indicates birthweight group (1 = ≥3kg, 2 = <3kg), and "set" identifies the matched pair.

How many infants are in the dataset? How many cases and controls? What does the variable "set" refer to?

```{r q1_explore}
# Total observations
nrow(diabraz)

# Cases and controls
diabraz |> count(case)

# Check the matching structure
diabraz |> count(case, set) |> 
  pivot_wider(names_from = case, values_from = n)
```

There are 172 observations: 86 cases and 86 controls. Each "set" contains exactly one case and one control, so we have 86 matched pairs. This is called 1:1 matching.

---

## Questions 2-3: Matched Analysis for Breastfeeding

In a matched case-control study, we construct a matched table rather than a standard 2×2 table. In a matched table for 1:1 matching, each cell represents the number of pairs with a given combination of case and control exposure status. The rows represent the control's exposure status and the columns represent the case's exposure status.

First, we need to recode the breastfeeding variable. In this dataset, bf is coded as 1 = breastfed and 2 = not breastfed. For analysis, we want the exposure to be "not breastfed" (since we expect this to increase risk), coded as 1 = not breastfed and 0 = breastfed.

```{r q2_recode}
# Recode bf: 1 = breastfed -> 0, 2 = not breastfed -> 1
diabraz <- diabraz |> 
  mutate(not_breastfed = case_when(
    bf == 1 ~ 0,
    bf == 2 ~ 1
  ))

# Check the recoding
diabraz |> count(bf, not_breastfed)
```

Now create the matched table and calculate the matched odds ratio. The `matched_or()` function creates a table where each cell represents paired data: the number of pairs where the control has a given exposure status (rows) and the case has a given exposure status (columns).

```{r q2_matched_table}
# Matched table and OR for breastfeeding
matched_or(diabraz, 
           case_var = "case", 
           exposure_var = "not_breastfed", 
           match_var = "set")

```

Interpretation of the matched table: The key cells are the discordant pairs (off-diagonal). Cell b shows pairs where the case was not breastfed but the control was breastfed. Cell c shows pairs where the case was breastfed but the control was not. In matched analysis, the odds ratio equals the ratio of these discordant pairs: OR = b/c.

The concordant pairs (both exposed or both unexposed) do not contribute information about the exposure-disease association because within these pairs, the case and control have the same exposure status.

---

## Question 4: Matched Analysis for Birthweight

Now perform a similar analysis for birthweight (bwtgp). The variable is coded as 1 = ≥3kg and 2 = <3kg. We recode so that low birthweight (<3kg) is the exposure of interest.

```{r q4_birthweight}
# Recode bwtgp: 1 = >=3kg -> 0, 2 = <3kg -> 1
diabraz <- diabraz |> 
  mutate(low_birthweight = case_when(
    bwtgp == 1 ~ 0,
    bwtgp == 2 ~ 1
  ))

# Check
diabraz |> count(bwtgp, low_birthweight)

# Matched table and OR for birthweight
matched_or(diabraz, 
           case_var = "case", 
           exposure_var = "low_birthweight", 
           match_var = "set")


```


---

## Question 5: What If We Ignored the Matching?

What happens if we analyse these data as if they were unmatched? Let's construct standard 2×2 tables and calculate unmatched odds ratios.

```{r q5_unmatched}
# Unmatched analysis for breastfeeding
tab_bf <- table(diabraz$not_breastfed, diabraz$case)
tab_bf
calculate_or(tab_bf)

# Unmatched analysis for birthweight
tab_bwt <- table(diabraz$low_birthweight, diabraz$case)
tab_bwt
calculate_or(tab_bwt)
```

Compare these results to the matched analyses.

Ignoring the matching gives different odds ratio estimates. For breastfeeding, the unmatched OR is biased toward the null. This happens because matching was done on confounders, and ignoring the matching effectively ignores this confounding control. The magnitude and direction of bias from ignoring matching depends on the relationship between the matching variables, the exposure, and the outcome.

---

## Question 6: Conditional Logistic Regression

Conditional logistic regression is the regression approach for analysing matched case-control data. It accounts for the matching by stratifying on the matched sets. In R, we use the `clogit()` function from the survival package, which requires specifying the matching variable in `strata()`.

The key difference from standard logistic regression is that conditional logistic regression conditions on the total number of cases in each stratum (matched set). This means the model does not estimate an intercept, and the matching variables themselves cannot be included as covariates since their effects are absorbed by the stratification.

```{r q6_clogit_bf}
# Conditional logistic regression for breastfeeding
clogit(case ~ not_breastfed + strata(set), data = diabraz) |> 
  tbl_regression(exponentiate = TRUE)
```

The OR from conditional logistic regression matches exactly the OR from the matched table analysis. This demonstrates that for 1:1 matched data with a single binary exposure, the matched table analysis and conditional logistic regression give identical results.

```{r q6_clogit_bwt}
# Conditional logistic regression for birthweight
clogit(case ~ low_birthweight + strata(set), data = diabraz) |> 
  tbl_regression(exponentiate = TRUE)
```

Again, the conditional logistic regression OR matches the matched table OR.

---

# Part 2: Multiple Controls per Case

## Question 7: A More Complex Dataset

Now load diabraz2, which has 2 controls matched to each case. This is called 1:2 matching.

```{r q7_import}
# Import data with 2 controls per case
diabraz2 <- read_stata(here("sme-2026", "data", "diabraz2.dta"))

# Explore
glimpse(diabraz2)

# Check case/control counts
diabraz2 |> count(case)

# Check matching structure
diabraz2 |> 
  group_by(set) |> 
  summarise(n_cases = sum(case == 1),
            n_controls = sum(case == 0)) |> 
  count(n_cases, n_controls)
```

There are 86 cases and 172 controls, with each case matched to exactly 2 controls.

---

## Question 8: Analysis with Multiple Controls

For matched studies with multiple controls per case, the matched table approach becomes more complex (cells now represent matched sets rather than pairs). However, conditional logistic regression handles any matching ratio seamlessly.

Note that in diabraz2, breastfeeding is coded: 1 = breastfed, 2 = not breastfed. We need to recode appropriately.

```{r q8_recode}
# Recode bf in diabraz2: 1 = breastfed -> 0, 2 = not breastfed -> 1
diabraz2 <- diabraz2 |> 
  mutate(not_breastfed = case_when(
    bf == 1 ~ 0,
    bf == 2 ~ 1
  ))

# Check
diabraz2 |> count(bf, not_breastfed)


# matched table and OR 
matched_or(diabraz2, 
           case_var = "case", 
           exposure_var = "not_breastfed", 
           match_var = "set")

```

```{r q8_clogit}
# Conditional logistic regression for breastfeeding with 1:2 matching
clogit(case ~ not_breastfed + strata(set), data = diabraz2) |> 
  tbl_regression(exponentiate = TRUE)
```

---

## Question 13: Assessing Confounding

Investigate whether social class (social) or maternal education (meduc) confound the association between breastfeeding and diarrhoea mortality. In matched case-control studies, we assess confounding by adding potential confounders to the conditional logistic regression model and examining whether the exposure OR changes.

First, let's examine the variables and convert them to factors.

```{r q13_prep}
# Check the variables
diabraz2 |> count(social)
diabraz2 |> count(meduc)

# Convert to factors
diabraz2 <- diabraz2 |> 
  mutate(
    social_f = as.factor(social),
    meduc_f = as.factor(meduc)
  )
```


Now fit a model with both confounders together - in general, if you believe both variables to be confounders, you should adjust for both variables since they both contribute to confounding of the exposure outcome relationship.

```{r q13_both}
# Unadjusted for both social class and maternal education
mod_unadj <- clogit(case ~ not_breastfed + strata(set), 
                   data = diabraz2)

mod_unadj |> 
  tbl_regression(exponentiate = TRUE)

# Adjusted for both social class and maternal education
mod_adj <- clogit(case ~ not_breastfed + social_f + meduc_f + strata(set), 
                   data = diabraz2)

mod_adj |> 
  tbl_regression(exponentiate = TRUE)
```

Compare the breastfeeding ORs across models:

```{r q13_compare}
# Compare unadjusted and adjusted ORs side by side
tbl_merge(
  list(
    tbl_regression(mod_unadj, 
                   exponentiate = TRUE, 
                   include = not_breastfed,
                   label = list(not_breastfed = "Not breastfed")),
    tbl_regression(mod_adj, 
                   exponentiate = TRUE, 
                   include = not_breastfed,
                   label = list(not_breastfed = "Not breastfed"))
  ),
  tab_spanner = c("**Unadjusted**", "**Adjusted**")
)
```

What do you conclude?

---

# Part 3: Frequency Matching (Pen and Paper)

When matching is done on categorical variables (e.g., age groups), cases and controls may be matched in groups rather than individually. This is called frequency matching. The analysis typically uses Mantel-Haenszel methods or standard logistic regression with the matching variables included as covariates, rather than conditional logistic regression.


